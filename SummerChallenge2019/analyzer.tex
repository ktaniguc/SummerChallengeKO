
\section{データ解析}
\subsection{MPPCで取得されるデータの解析}
MPPCで取得されるデータはEASIROCによってtree形式で保存される。今回はこのデータをROOTを用いて解析を行う。ここから解析に必要なROOTの知識を簡単に説明するが、すべてを説明することはできないためわからない部分は各自調べるかTAに質問したりするようにしてください。

\subsection{ROOTとは}
ROOTとはCERNが開発したデータ解析のためのフレームワークであり、特によく使われる目的としてはヒストグラム・グラフを描く、任意の関数でフィットする、大量のデータを処理するといったものがある。物理学実験では大量のデータを扱うため、例えばエクセルのようなものではそれらのデータをプロットしたり複雑な解析を行うことは難しくなる。そのため、プログラミングによる解析を行えるようになる必要がある。言語としては主にC++で動作し、pythonで書くこともできるが自分がよく知らないため説明はC++のみとなる。また、ROOTで行えることは膨大であるため、できる限り今回必要となる最低限について説明するつもりだがわからない部分も出てくると思うので、それに関してはTAに聞いたり調べたりしてみてください。
ROOTをインストールもしくはROOTがインストールされているマシンにSSH接続して、ROOTを使用できる環境が構築できていることを仮定して、以下で使い方について説明する。

\subsubsection{Building ROOT}

\vspace{1cm}
Windows版
\vspace{0.5cm}

\vspace{1cm}
\Large{Mac版}
\normalsize{}

\vspace{0.5cm}
Homebrew
\vspace{0.3cm}

HomebrewはmacOS用のパッケージマネージャーです。
HomebrewでROOTビルドに必要なCmakeをInstallします。

\href{https://brew.sh/index_ja.html}{https://brew.sh/index_ja.html}

上記のURLよりmacのターミナルにHPに書かれているコマンドを入力する。


\vspace{0.5cm}
ROOT
\vspace{0.3cm}

Git~Clone~コマンドを用いてROOTのSource~fileをDownloadする。

\href{https://root.cern.ch/building-root}{https://root.cern.ch/building-root}

こちらを参考にCmakeを用いてBuildを行う。


\subsubsection{ROOTの起動方法}
ROOTを起動するためには単にコマンドラインでrootと入力するだけでよい。しかし、rootと入力するだけでは毎回図\ref{fig:ROOT_logo}が表示され、邪魔になるので普段は表示しないようにしたほうがよい。
\begin{figure}[ht]
\begin{center}
\includegraphics[width=8cm]{ROOT_logo.png}
\caption{ROOTのロゴ}
\label{fig:ROOT_logo}
\end{center}
\end{figure}
表示させないためには起動させる際にオプションで-lをつければよい。
\begin{table}[ht]
  \caption{ROOT起動時のオプションの例}
  \centering
  \begin{tabular}{lcr}
    \hline
    オプション  & 意味 \\
    \hline \hline
      -l:  & 起動時にロゴを表示しない  \\
      -b:  & ヒストグラムやグラフのグラフィックを描画しない \\
      -q:  & スクリプトファイルを実行後自動でROOTが終了する \\
    \hline
  \end{tabular}
\end{table}
ROOTを終了したいときには、.qと入力すればROOTを終了させることができる。

\subsubsection{ヒストグラムの描き方}
rootを起動する際に、引数にrootファイルを指定することでrootの起動と同時にROOTファイルを開くことができる。例えば、今回測定結果をexample.rootという名前で保存しているとした場合、root example.rootとコマンドラインから入力することで測定データに簡単にアクセスすることができる。\ref{fig:open_ROOT}
\begin{figure}[h]
\begin{center}
\includegraphics[width=8cm]{SummerChallenge_open_root.png}
\caption{rootファイルを開く}
\label{fig:open_ROOT}
\end{center}
\end{figure}

example.root内にさらにtreeという名前でtreeを作っている場合、tree-$>$''コマンド''という書き方をすることができる。それにより、簡単に測定データを確認したりヒストグラムを描くことができる。コマンドとしては例えば、tree-$>$Print$\left(\right)$やtree-$>$Scan$\left(\right)$があり、Printはデータの数や種類、変数の方を確認でき、Scanは1つ1つのデータを実際に確認することができる。
\begin{figure}[htbp]
\begin{center}
  \begin{tabular}{c}

    \begin{minipage}{0.5\hsize}
      \begin{center}
        \includegraphics[clip, width=60mm]{SummerChallenge_tree_print.png}
        \hspace{1.6cm} (a)tree-$>$Print$\left(\right)$の実行例
      \end{center}
    \end{minipage}

    \begin{minipage}{0.5\hsize}
      \begin{center}
        \includegraphics[clip, width=60mm]{SummerChallenge_tree_scan.png}
        \hspace{1.6cm} (b)tree-$>$Scan$\left(\right)$の実行例
      \end{center}
    \end{minipage}
  \end{tabular}
  \end{center}
\end{figure}

今回treeの中身をPrintやScanで確認すると、いくつかのBranchがあると思う。\footnote{Branchとは言葉通り枝のようなもので、1つのEntryに対して様々なデータを詰め込むことができる。}そのうち今回adcというBranchのヒストグラムを描きたい場合、tree-$>$Draw$\left(''adc''\right)$と打つだけでヒストグラムを描くことができる。\footnote{今回、EASIROCでは32chのデータが配列としてadcのBranchに入っており、そのうちMPPCがつながっているのは30chのみなので、adc[30]のみをDrawすることで測定データのヒストグラムを描ける}
\begin{figure}[htbp]
\begin{center}
  \begin{tabular}{c}

    \begin{minipage}{0.5\hsize}
      \begin{center}
        \includegraphics[clip, width=60mm]{SummerChallenge_tree_draw_adc.png}
        \hspace{1.6cm} (a)tree-$>$Draw(''adc'')の実行例
      \end{center}
    \end{minipage}

    \begin{minipage}{0.5\hsize}
      \begin{center}
        \includegraphics[clip, width=60mm]{SummerChallenge_tree_draw_adc30.png}
        \hspace{1.6cm} (b)tree-$>$Draw(''adc[30]'')の実行例
      \end{center}
    \end{minipage}
  \end{tabular}
  \label{fig:tree_draw}
  \end{center}
\end{figure}

ヒストグラムを書くときに、ただそのまま書くだけでなく様々な条件をかけることもできる。例えば、tree-$>$Draw(''adc*2'')とすれば、adcの値を2倍したヒストグラムを描くことができ、tree-$>$Draw(''adc'',''adc>900'')とすればadcが900より大きいイベントのみ描くことができます。この条件には、ほかのBranchを用いることもできtree-$>$Draw(''adc'',''adc\_l $>$ 1000 \&adc\_l $<$ 3000'')とすれば1000$<$adc\_l$<$3000のみのヒストグラムを描くことができる。ただし、ある程度複雑な条件になってくるとこの書き方をするのは難しくなってくるので、後述するマクロを書いてヒストグラムを描くことをお勧めする。

最後にtreeをそのままdrawする以外のヒストグラムの描き方として、Fillという方法がある。簡単な例として、自分でガウス分布に従う乱数を発生させてそれをヒストグラムに詰めるやり方を紹介する。
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
    TH1D *h1 = new TH1D(''h1'',''h1'',50,-5,5);
    for(Int_t i = 0;i < 10000;i++){
     Double_t x = gRandom->Gaus();
     h1->Fill(x);
    }  
    h1->Draw();
 \end{lstlisting}
 ３行目でgRandomというものを用いてGauss分布に従う乱数を発生させ、それを4行目でFillというコマンドでh1のヒストグラムに詰めている。それをfor文で回して10000回詰めている。このヒストグラムをDrawすることでGauss分布に従うヒストグラムを描くことができる。今回は例として乱数をFillしたが、乱数の代わりに詰めたい値を詰めることで好きなヒストグラムを描くことができる。

\subsubsection{マクロの書き方}
簡単なマクロはコマンドラインに書いてヒストグラムを描くときと同じものを描くだけでよい。ただし、rootファイルを読み込む際には必要な手順があるので例としてそれを示す。
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
void macro(){
	TFile *file = new TFile("example.root");
	TH1D *h1 = (TH1D*)file->Get("adc");
	h1->Draw();
}
 \end{lstlisting}
というファイルを作り、ターミナル上でroot macro.cxxやrootを起動した後、.x macro.cxxとコマンドすることでこのマクロを実行できる。
データの解析には基本的にはROOT固有の知識はそれほど必要ではなく、c++の知識があれば充分であるため深くは説明しない。

もう一つ必要な知識として、詳しい解析を行う際にはBranchのデータをヒストグラムとしてではなく値として取り出す必要がある。そのためこれも簡単にではあるが、値としての取り出し方を説明する。

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
void macro(){
    TFile *file = new TFile(inputfilename, "read"); 
    TTree *tree = (TTree*)file->Get("tree");
 
    Double_t adc[32]
    tree->SetBranchAddress("adc", &adc);
 
    const Int_t N = tin->GetEntries();
    for (Int_t ientry = 0; ientry < N; ientry++) {
     tree->GetEntry(ientry);    
     cout<<ientry<<''   ''<<adc[30]<<endl;
   }
}
 \end{lstlisting}

tree-$>$GetEntry(ientry)とすることで、ientry番目のイベントのadcを読み込んでおり、それをfor文で全イベント回すことで全データを読み込んでいる。今回のマクロではcoutで出力しているだけだが、その値をvectorや配列に詰めることで解析に用いることができる。

コマンドラインによる解析の仕方も一応説明しているが、測定直後にデータを簡単に確認したいといった場合を除いてはマクロを用いればよい。また、データを確認する場合でもTBrowser\footnote{ROOTを起動した後、TBrowser tbと入力することでrootファイルの中身をヒストグラムとして簡単に見ることができる}が便利であるため、あまり使用頻度は高くないと思われる。

\subsubsection{ヒストグラムのフィット}
ROOTにはあらかじめガウス分布やポアソン分布などの様々な関数が用意されており、それらをヒストグラムのフィットを行う際に利用できる。例えばガウス分布でフィットする際には、htemp-$>$Fit(''gaus'')とすればよい。\footnote{htempの部分はその時のヒストグラムの名前に応じて適宜変える}コマンドラインで行った場合にはコマンドラインにfitの結果が出力される。
\begin{figure}[h]
\begin{center}
\includegraphics[width=8cm]{SummerChallenge_fit_gaus.png}
\caption{フィットの結果}
\label{fig:fit_gaus}
\end{center}
\end{figure}

ガウス分布の場合は、$(gaus)=(Constant)\times$exp$(-\frac{(x-(Mean))^2}{2(Sigma)^2})$で定義されている。それぞれの出力されるパラメータは関数によって異なるため、ほかの関数を用いる際は一度確認しておくとよい。
また、htemp-$>$Fit(''gaus'','''','''',min,max)とすることでフィットする範囲を制限することができる。

あらかじめ定義されている関数以外の関数を用いたい場合は自分で定義することができる。例えば直線でフィットしたい場合には、
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
TF1 *f1 = new TF1(''f1'',''[0] + [1] * x'',min,max);
 \end{lstlisting}
とすることでまず直線の関数を定義することができる。この関数の名前はf1になっているので、あとは先ほどガウス分布でフィットしたときと同様に、
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
htemp->Fit(''f1'','''','''',min,max);
 \end{lstlisting}
とすればよい。

フィットする際にある程度のパラメータを指定したい場合がある。その際にはf1->SetParameter(0,5)とすれば0番目のパラメータの初期値を5に設定でき、f1->SetParameters(5,10)とすればまとめて複数のパラメータの初期値を設定できる。

マクロで行う場合には基本的には同じだが、フィットした結果をマクロ内で用いたい場合は値として取り出す必要がある。
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
Double_t p0 = f1->GetParameter(0);
 \end{lstlisting}
とすると、p0にフィットした後の0番目のパラメータの値を代入することができる。

\subsubsection{グラフの描き方}
基本的な使い方として、テキストファイルからグラフを描くやり方と配列やvector\footnote{vectorが何かわからない場合はc++の勉強が先に必要なため、c++ vector等で検索して使い方を勉強したほうがよいでしょう}を用いる方法がある。まずはテキストファイルでのグラフの書き方から説明する。

例としてdata.datというファイルに
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
1.00 3936
0.50 3007
0.10 2249
-0.10 1836
-0.50 1097
-1.00 146
 \end{lstlisting}
 と書かれている場合、簡単にグラフを描くことができ
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
TGraph *tg1 = new TGraph(''data.dat'');
tg1->Draw(''AP'');
 \end{lstlisting}
とするだけでグラフを描くことができる。ただし、この方法を用いるためには結果をまずdatファイルとして出力する必要があるため、あまり使うことはないだろう。

配列やvectorを用いる場合、まずは配列やvectorにデータを詰める必要があり、その部分は省略する。すでに値が詰まっていると仮定すると、配列の場合は
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
TGraph *tg1 = new TGraph(6,x,y);
tg1->Draw(''AP'');
 \end{lstlisting}
とすると、6個のデータを含むグラフを描くことができる。しかし、測定データによってグラフが何点あるかは異なる場合もあり、vectorを用いたほうが様々な場合に柔軟に用いることができ便利である。

vectorを用いた場合は
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
TGraph *tg1 = new TGraph(x.size(),&(x.at(0)),&(y.at(0)));
tg1->Draw(''AP'');
 \end{lstlisting}
c++の知識がある人は、これを見てやってることは同じだとわかると思う。

また、グラフにエラーバーをつけたい場合も多いと思う。その場合はTGraphではなくTGraphErrorsを用いればよい。使い方はほとんど同じで、
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
TGraph *tg1 = new TGraph(6,x,x_error,y,y_error);
tg1->Draw(''AP'');
 \end{lstlisting}
 の順番に引数がなっており、その通りにTGraphの時と同様に配列やvectorで与えればよい。

最後にグラフのフィットについてであるが、ヒストグラムの場合と全く同じであり例えば直線でフィットしたい場合には
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
TF1 *f1 = new TF1(''f1'',''[0] + [1] * x'',min,max);
tg1->Fit(''f1'','''','''',min,max);
 \end{lstlisting}
とすればグラフを直線でフィットすることができる。

\subsubsection{結果の保存}
コマンドラインで結果のヒストグラムやグラフを保存する場合には、左上のFileからSave Asを選ぶと名前を付けて保存することができる。マクロで実行している場合には、ヒストグラムやグラフを描く前に
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
TCanvas *c1 = new TCanvas(''c1'',''c1'',1600,900);
 \end{lstlisting}
としてキャンバスを作っておき、ヒストグラムやグラフをDrawした後に
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
c1->SaveAs(''save name'');
 \end{lstlisting}
とすることで保存することができる。保存する際にきれいにヒストグラムやグラフを整えた後、保存したい人も多いと思う。rootはヒストグラムやグラフそれぞれに様々な修飾等が存在し、それをここで説明しているときりがないためまとめ\ref{sec:lastsection}にそれらが書かれているリンクを載せておく。

また、ヒストグラムを保存する際に画像としてでなくrootファイルにヒストグラムのまま保存することができる。実際に触ってみないとそのメリットは感じにくいかもしれないが、rootファイルの状態で保存することで、保存した後にタイトルをつけたりbin幅を変えるといった加工が簡単に行える。そのため、最終的にスライド等に用いる時以外はrootファイルで保存しておいたほうが便利かもしれない。具体的なやり方が書かれているサイトのリンクをここに載せておく。\footnote{\url{https://www-he.scphys.kyoto-u.ac.jp/member/n.kamo/wiki/doku.php?id=study:software:root:io}のWrite ・オブジェクトをファイルに書き込む、rootファイルを保存するを参考にしてもらえばよい。}なお、ヒストグラム等を保存する際は測定データのrootファイルとは別に保存用のrootファイルを作るようにしてください。測定データを上書きしてしまうリスクを避けるために、測定データは読み込み専用で開く習慣をつけるためである。

\subsection{Poisson統計}
Poisson分布とはめったに起こらない事象を大量に測定した場合にこの分布に従うことが多い。式で表すと、
\begin{equation}
P\left(n\right)=\frac{\lambda^n e^{-\lambda}}{n!}
\end{equation}
で、これは平均$\lambda$起こる事象がn回起こるときの確率を表す。今回の実験の場合はそれぞれの測定での光子数の分布はPoisson分布に従うと思われる。
\begin{figure}[h]
\begin{center}
\includegraphics[width=8cm]{SummerChallenge_poisson.png}
\caption{poisson分布の図}
\label{fig:poisson}
\end{center}
\end{figure}

$\lambda$が大きい場合はPoison分布はGauss分布(正規分布)に従う。今回の実験の場合では、それぞれの光子数に対応するピークはGauss分布に従うと思われる。
\begin{figure}[h]
\begin{center}
\includegraphics[width=8cm]{SummerChallenge_gauss.png}
\caption{gauss分布の図}
\label{fig:gauss}
\end{center}
\end{figure}

\subsection{干渉縞の再現}
今回の測定データは最初adcの値として保存されており、この値自体に物理的な意味はない。そのため、まずはこの値から光子数に変換する必要がある。やり方としてはそれぞれのピークが光子数に対応しているため、それぞれをガウス分布でフィットして中心値を求める。そのadc値と光子数の関係を直線近似することで横軸をadcから光子数に変換することができる。

そのあと、変換した後のヒストグラムからMPPCの位置ごとの平均光子数を求めてプロットすることで干渉縞を再現することができる。平均光子数については様々な求め方があるが、簡単なものについては光子数で重みづけした平均、もう少しちゃんと求める場合には上で述べたように光子数の分布はPoisson分布に従うため、全体をPoisson分布でフィットすることで求めるほうがよい。

また、演習３で光子数を減らした場合はフィットで平均光子数を求めることは難しい。その場合は平均光子数ではなく1光子以上のイベント数で考えるとよい。平均光子数そのものではないが、光子数が少ない場合には平均光子数に比例して1光子以上のイベント数も増加するため、それでも干渉縞を観測することができる。\footnote{物理的な説明をすると、1光子の干渉と仮定すると明線の部分では光子の存在確率が大きいため、光子を観測するイベント数が増加する。光子数が増加すると光子数0となるイベントは暗線であっても減少するため、この考え方で解析することは難しくなる。}

